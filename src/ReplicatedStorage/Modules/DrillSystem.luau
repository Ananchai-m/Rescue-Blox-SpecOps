-- DrillSystem ModuleScript
-- ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏à‡∏≤‡∏∞‡πÅ‡∏•‡∏∞‡∏ó‡∏≥‡∏•‡∏≤‡∏¢ Motor6D

local DrillConfig = require(script.Parent.DrillConfig)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CoinEffect = require(script.Parent.CoinEffect)

local DrillSystem = {}

-- Private variables
local drillingTargets = {} -- ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏à‡∏≤‡∏∞‡πÅ‡∏ï‡πà‡∏•‡∏∞ part
local recentlyCompleted = {} -- ‡πÄ‡∏Å‡πá‡∏ö part ‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏á‡πÄ‡∏à‡∏≤‡∏∞‡πÄ‡∏™‡∏£‡πá‡∏à‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á
local currentDrillingPart = nil -- Part ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏à‡∏≤‡∏∞‡∏≠‡∏¢‡∏π‡πà
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- UI Variables
local drillGui = nil
local drillContainer = nil
local drillPartLabel = nil
local drillStatusLabel = nil
local drillProgressBar = nil
local drillProgressFill = nil
local drillHideThread = nil

-- ===== UI FUNCTIONS =====

local function cancelDrillHideThread()
	if drillHideThread then
		task.cancel(drillHideThread)
		drillHideThread = nil
	end
end

local function ensureDrillProgressGui()
	if drillGui then
		return
	end

	local playerGui = player:WaitForChild("PlayerGui")
	drillGui = Instance.new("ScreenGui")
	drillGui.Name = "DrillProgressGui"
	drillGui.ResetOnSpawn = false
	drillGui.DisplayOrder = 500
	drillGui.Parent = playerGui

	drillContainer = Instance.new("Frame")
	drillContainer.Name = "Container"
	drillContainer.Size = UDim2.new(0, 260, 0, 90)
	drillContainer.Position = UDim2.new(0.5, -130, 0.78, 0)
	drillContainer.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
	drillContainer.BackgroundTransparency = 0.2
	drillContainer.BorderSizePixel = 0
	drillContainer.Visible = false
	drillContainer.Parent = drillGui

	local containerCorner = Instance.new("UICorner")
	containerCorner.CornerRadius = UDim.new(0, 12)
	containerCorner.Parent = drillContainer

	drillPartLabel = Instance.new("TextLabel")
	drillPartLabel.Name = "PartLabel"
	drillPartLabel.Size = UDim2.new(1, -20, 0, 24)
	drillPartLabel.Position = UDim2.new(0, 10, 0, 10)
	drillPartLabel.BackgroundTransparency = 1
	drillPartLabel.Font = Enum.Font.GothamMedium
	drillPartLabel.Text = ""
	drillPartLabel.TextColor3 = Color3.fromRGB(230, 230, 230)
	drillPartLabel.TextSize = 20
	drillPartLabel.TextWrapped = true
	drillPartLabel.Parent = drillContainer

	drillStatusLabel = Instance.new("TextLabel")
	drillStatusLabel.Name = "StatusLabel"
	drillStatusLabel.Size = UDim2.new(1, -20, 0, 20)
	drillStatusLabel.Position = UDim2.new(0, 10, 0, 40)
	drillStatusLabel.BackgroundTransparency = 1
	drillStatusLabel.Font = Enum.Font.Gotham
	drillStatusLabel.Text = ""
	drillStatusLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
	drillStatusLabel.TextSize = 16
	drillStatusLabel.TextWrapped = true
	drillStatusLabel.Parent = drillContainer

	drillProgressBar = Instance.new("Frame")
	drillProgressBar.Name = "ProgressBar"
	drillProgressBar.Size = UDim2.new(1, -40, 0, 16)
	drillProgressBar.Position = UDim2.new(0, 20, 0, 62)
	drillProgressBar.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	drillProgressBar.BorderSizePixel = 0
	drillProgressBar.Parent = drillContainer

	local barCorner = Instance.new("UICorner")
	barCorner.CornerRadius = UDim.new(0, 8)
	barCorner.Parent = drillProgressBar

	drillProgressFill = Instance.new("Frame")
	drillProgressFill.Name = "Fill"
	drillProgressFill.Size = UDim2.new(0, 0, 1, 0)
	drillProgressFill.Position = UDim2.new(0, 0, 0, 0)
	drillProgressFill.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
	drillProgressFill.BorderSizePixel = 0
	drillProgressFill.Parent = drillProgressBar

	local fillCorner = Instance.new("UICorner")
	fillCorner.CornerRadius = UDim.new(0, 8)
	fillCorner.Parent = drillProgressFill
end

local function hideDrillProgress()
	cancelDrillHideThread()
	if drillContainer then
		drillContainer.Visible = false
	end
end

local function showDrillProgress(payload)
	print("DrillSystem.showDrillProgress called with payload:", payload)
	ensureDrillProgressGui()
	if not drillContainer then
		warn("DrillSystem: drillContainer is nil after ensureDrillProgressGui")
		return
	end

	if payload.status == "cancel" then
		print("DrillSystem: Hiding progress (cancel)")
		hideDrillProgress()
		return
	end

	cancelDrillHideThread()
	drillContainer.Visible = true
	print("DrillSystem: Container set to visible")

	local partName = payload.partName or ""
	local clicks = payload.clicks or 0
	local required = payload.requiredClicks or 1
	local progress = math.clamp(payload.progress or 0, 0, 1)

	drillPartLabel.Text = partName ~= "" and partName or "Unknown Part"
	if payload.status == "complete" then
		drillStatusLabel.Text = string.format("‡πÄ‡∏à‡∏≤‡∏∞‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (%d/%d)", clicks, required)
	elseif payload.status == "info" then
		drillStatusLabel.Text = "DrillArm ‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö Part"
	else
		drillStatusLabel.Text = string.format("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏à‡∏≤‡∏∞... (%d/%d)", clicks, required)
	end
	drillProgressFill.Size = UDim2.new(progress, 0, 1, 0)

	print(string.format("DrillSystem: Updated UI - %s (%d/%d) %.0f%%", partName, clicks, required, progress * 100))

	if payload.status == "complete" then
		drillHideThread = task.delay(DrillConfig.HIDE_DELAY, function()
			drillHideThread = nil
			hideDrillProgress()
		end)
	end
end

-- ===== DRILL DETECTION FUNCTIONS =====

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤ Part ‡πÄ‡∏õ‡πá‡∏ô body part ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
local function isBodyPart(part)
	local bodyParts = {
		"LeftFoot", "LeftHand", "LeftLowerArm", "LeftLowerLeg", "LeftUpperArm", "LeftUpperLeg",
		"LowerTorso", "RightFoot", "RightHand", "RightLowerArm", "RightLowerLeg",
		"RightUpperArm", "RightUpperLeg", "UpperTorso", "Head", "HumanoidRootPart"
	}
	for _, bodyPartName in ipairs(bodyParts) do
		if part.Name == bodyPartName then
			return true
		end
	end
	return false
end

local function findDrillablePartsNearPosition(position, range)
	local foundParts = {}

	-- ‡∏´‡∏≤ Obstacles folder (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á)
	local obstaclesFolder = nil

	-- ‡∏•‡∏≠‡∏á‡∏´‡∏≤‡πÉ‡∏ô Building_LV1 ‡∏Å‡πà‡∏≠‡∏ô
	local buildingLV1 = workspace:FindFirstChild("Building_LV1")
	if buildingLV1 then
		obstaclesFolder = buildingLV1:FindFirstChild("Obstacles")
	end

	-- ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ ‡∏•‡∏≠‡∏á‡∏´‡∏≤‡∏ï‡∏£‡∏á‡πÜ ‡πÉ‡∏ô workspace
	if not obstaclesFolder then
		obstaclesFolder = workspace:FindFirstChild("Obstacles")
	end

	-- ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á workspace
	local searchContainer = obstaclesFolder or workspace

	if not obstaclesFolder then
		print("DrillSystem: Obstacles folder not found, searching entire workspace")
	else
		print("DrillSystem: Found Obstacles at", obstaclesFolder:GetFullName())
	end

	-- ‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠ Model ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡πâ‡∏≤‡∏°
	local ignoredModels = {}

	-- ‡πÄ‡∏û‡∏¥‡πà‡∏° character ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô
	for _, otherPlayer in pairs(Players:GetPlayers()) do
		if otherPlayer.Character then
			ignoredModels[otherPlayer.Character] = true
		end
	end

	-- ‡πÄ‡∏û‡∏¥‡πà‡∏° Rescue models ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô
	for _, otherPlayer in pairs(Players:GetPlayers()) do
		local rescueCompanion = workspace:FindFirstChild(otherPlayer.Name .. "_RescueCompanion")
		local rescueModel = workspace:FindFirstChild(otherPlayer.Name .. "_Rescue")
		if rescueCompanion then
			ignoredModels[rescueCompanion] = true
		end
		if rescueModel then
			ignoredModels[rescueModel] = true
		end
	end

	-- ‡πÄ‡∏û‡∏¥‡πà‡∏° Victims ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
	for _, obj in pairs(workspace:GetChildren()) do
		if obj:IsA("Model") and string.find(obj.Name, "Victim_") then
			ignoredModels[obj] = true
		end
	end

	-- ‡∏´‡∏≤ Part/MeshPart
	for _, obj in pairs(searchContainer:GetDescendants()) do
		if (obj:IsA("BasePart") or obj:IsA("MeshPart")) and obj.Anchored then
			-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô ignored models
			local shouldIgnore = false
			local ancestor = obj.Parent
			while ancestor and ancestor ~= workspace do
				if ignoredModels[ancestor] then
					shouldIgnore = true
					break
				end
				ancestor = ancestor.Parent
			end

			-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà body part
			if not shouldIgnore and not isBodyPart(obj) then
				-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á
				local distance = (obj.Position - position).Magnitude
				if distance <= range and not recentlyCompleted[obj] then
					-- ‡πÄ‡∏Å‡πá‡∏ö parts ‡∏ó‡∏µ‡πà‡πÄ‡∏à‡∏≤‡∏∞‡πÑ‡∏î‡πâ
					table.insert(foundParts, {
						part = obj,
						distance = distance
					})
				end
			end
		end
	end

	-- ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
	table.sort(foundParts, function(a, b)
		return a.distance < b.distance
	end)

	return foundParts
end


-- ===== DRILL LOGIC FUNCTIONS =====

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤‡∏ä‡∏¥‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ Raycast ‡πÉ‡∏ô 6 ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÉ‡∏ô Obstacles)
local function findConnectedParts(startPart, visitedParts, maxDepth)
	visitedParts = visitedParts or {}
	maxDepth = maxDepth or 3 -- ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∂‡∏Å‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏´‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏Å‡∏≠‡∏á)

	if maxDepth <= 0 or visitedParts[startPart] then
		return visitedParts
	end

	visitedParts[startPart] = true

	-- ‡∏´‡∏≤ Obstacles folder (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á)
	local obstaclesFolder = nil
	local buildingLV1 = workspace:FindFirstChild("Building_LV1")
	if buildingLV1 then
		obstaclesFolder = buildingLV1:FindFirstChild("Obstacles")
	end
	if not obstaclesFolder then
		obstaclesFolder = workspace:FindFirstChild("Obstacles")
	end

	-- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤ part ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô Obstacles folder ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å‡∏ä‡∏∑‡πà‡∏≠)
	local isInObstacles = false
	local ancestor = startPart.Parent
	while ancestor and ancestor ~= workspace do
		if ancestor.Name == "Obstacles" then
			isInObstacles = true
			break
		end
		ancestor = ancestor.Parent
	end

	if not isInObstacles then
		return visitedParts
	end

	-- ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á 6 ‡∏î‡πâ‡∏≤‡∏ô: ‡∏ö‡∏ô, ‡∏•‡πà‡∏≤‡∏á, ‡∏´‡∏ô‡πâ‡∏≤, ‡∏´‡∏•‡∏±‡∏á, ‡∏ã‡πâ‡∏≤‡∏¢, ‡∏Ç‡∏ß‡∏≤
	local directions = {
		Vector3.new(0, 1, 0),   -- ‡∏ö‡∏ô
		Vector3.new(0, -1, 0),  -- ‡∏•‡πà‡∏≤‡∏á
		Vector3.new(0, 0, 1),   -- ‡∏´‡∏ô‡πâ‡∏≤
		Vector3.new(0, 0, -1),  -- ‡∏´‡∏•‡∏±‡∏á
		Vector3.new(1, 0, 0),   -- ‡∏Ç‡∏ß‡∏≤
		Vector3.new(-1, 0, 0)   -- ‡∏ã‡πâ‡∏≤‡∏¢
	}

	-- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞ Raycast ‡∏à‡∏≤‡∏Å Size ‡∏Ç‡∏≠‡∏á Part
	local partSize = startPart.Size
	local rayDistance = math.max(partSize.X, partSize.Y, partSize.Z) * 0.6 -- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏£‡∏∞‡∏¢‡∏∞‡πÉ‡∏Å‡∏•‡πâ‡πÜ

	-- ‡∏™‡∏£‡πâ‡∏≤‡∏á RaycastParams
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Exclude
	rayParams.FilterDescendantsInstances = {character} -- ‡πÑ‡∏°‡πà‡πÄ‡∏ä‡πá‡∏Ñ‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£

	for _, direction in ipairs(directions) do
		-- ‡∏¢‡∏¥‡∏á Ray ‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡∏®‡∏π‡∏ô‡∏¢‡πå‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á Part
		local origin = startPart.Position
		local rayDirection = direction * rayDistance

		local rayResult = workspace:Raycast(origin, rayDirection, rayParams)

		if rayResult and rayResult.Instance then
			local hitPart = rayResult.Instance

			-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ hitPart ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô Obstacles folder (‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å‡∏ä‡∏∑‡πà‡∏≠)
			local hitIsInObstacles = false
			local hitAncestor = hitPart.Parent
			while hitAncestor and hitAncestor ~= workspace do
				if hitAncestor.Name == "Obstacles" then
					hitIsInObstacles = true
					break
				end
				hitAncestor = hitAncestor.Parent
			end

			-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô BasePart/MeshPart, Anchored, ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô Obstacles, ‡πÅ‡∏•‡∏∞‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏Ñ‡∏¢‡πÄ‡∏à‡∏≠
			if hitIsInObstacles and
			   (hitPart:IsA("BasePart") or hitPart:IsA("MeshPart")) and
			   hitPart.Anchored and
			   not visitedParts[hitPart] then
				-- ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏ã‡πâ‡∏≥‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤ connected parts ‡∏ï‡πà‡∏≠‡πÑ‡∏õ
				findConnectedParts(hitPart, visitedParts, maxDepth - 1)
			end
		end
	end

	return visitedParts
end

local function startDrilling(partData)
	local part = partData.part
	local partName = part.Name

	-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏à‡∏≤‡∏∞ Part ‡πÄ‡∏î‡∏¥‡∏°‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
	if currentDrillingPart and currentDrillingPart ~= part then
		-- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô Part ‡∏ó‡∏µ‡πà‡πÄ‡∏à‡∏≤‡∏∞ - ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤
		print("Switching drilling target from", currentDrillingPart.Name, "to", partName)
		drillingTargets[currentDrillingPart] = nil
		hideDrillProgress()
	end

	-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Part ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏à‡∏≤‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
	currentDrillingPart = part

	-- ‡πÄ‡∏£‡∏¥‡πà‡∏° tracking ‡∏Å‡∏≤‡∏£‡πÄ‡∏à‡∏≤‡∏∞
	if not drillingTargets[part] then
		print("Starting new drilling session for:", partName)
		drillingTargets[part] = {
			clicks = 0,
			partName = partName,
			requiredClicks = DrillConfig.CLICKS_REQUIRED
		}
	else
		print("Continuing drilling session for:", partName, "Current clicks:", drillingTargets[part].clicks)
		-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï requiredClicks ‡πÉ‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô
		drillingTargets[part].requiredClicks = DrillConfig.CLICKS_REQUIRED
	end

	local target = drillingTargets[part]
	target.clicks = target.clicks + 1

	-- ‡πÅ‡∏™‡∏î‡∏á progress
	local progress = target.clicks / target.requiredClicks
	local payload = {
		partName = partName,
		clicks = target.clicks,
		requiredClicks = target.requiredClicks,
		progress = progress,
		status = "progress"
	}

	-- ‡∏ñ‡πâ‡∏≤‡πÄ‡∏à‡∏≤‡∏∞‡∏Ñ‡∏£‡∏ö 10 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡πÉ‡∏´‡πâ‡∏Å‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô‡πÄ‡∏™‡∏°‡∏≠ (‡πÅ‡∏ï‡πà‡∏™‡∏∏‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏£‡∏á)
	if target.clicks >= target.requiredClicks then
		-- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó payload - ‡∏Å‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô‡∏≠‡∏≠‡∏Å
		payload.status = "complete"
		payload.progress = 1

		-- ‡∏™‡∏∏‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏£‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô (50% ‡πÅ‡∏£‡∏á‡∏°‡∏≤‡∏Å, 50% ‡πÅ‡∏£‡∏á‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á)
		local ejectStrength = math.random(1, 100) <= 50 and "strong" or "weak"

		-- ‡∏´‡∏≤ Rescue bot position ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏Å‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô
		local rescueModelName = player.Name .. "_Rescue"
		local rescueModel = workspace:FindFirstChild(rescueModelName)
		local rescuePosition = nil
		if rescueModel and rescueModel.PrimaryPart then
			rescuePosition = rescueModel.PrimaryPart.Position
		end

		-- ‡∏´‡∏≤‡∏ä‡∏¥‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
		local connectedParts = findConnectedParts(part)
		local connectedCount = 0
		for _ in pairs(connectedParts) do
			connectedCount = connectedCount + 1
		end
		print("Found", connectedCount, "connected parts to", partName, "- Eject strength:", ejectStrength)

		-- ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡πà‡∏á‡πÑ‡∏õ Server ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ physics
		local ReplicatedStorage = game:GetService("ReplicatedStorage")
		local remoteEventsFolder = ReplicatedStorage:FindFirstChild("RescueBotRemotes")
		local drillCompleteRemote = remoteEventsFolder and remoteEventsFolder:FindFirstChild("DrillComplete")

		if drillCompleteRemote then
			-- ‡∏™‡∏£‡πâ‡∏≤‡∏á array ‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• parts ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏™‡πà‡∏á‡πÑ‡∏õ server
			local connectedPartsData = {}
			for connectedPart, _ in pairs(connectedParts) do
				if (connectedPart:IsA("BasePart") or connectedPart:IsA("MeshPart")) then
					table.insert(connectedPartsData, {
						Name = connectedPart.Name,
						Position = connectedPart.Position,
						Instance = connectedPart
					})
				end
			end

			-- ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ Server ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏£‡∏á
			local partData = {
				Name = part.Name,
				Position = part.Position,
				Instance = part
			}
			print("Sending", #connectedPartsData, "parts to server for physics simulation")
			drillCompleteRemote:FireServer(partData, connectedPartsData, rescuePosition, ejectStrength)
		else
			warn("DrillComplete RemoteEvent not found!")
		end

		-- ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏à‡∏≤‡∏∞‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤ recently completed
		print("Clearing drilling data for completed part:", partName)
		drillingTargets[part] = nil
		currentDrillingPart = nil -- ‡∏•‡πâ‡∏≤‡∏á Part ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
		recentlyCompleted[part] = true

		-- ‡∏•‡∏ö‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å recently completed ‡∏´‡∏•‡∏±‡∏á 0.5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (‡∏•‡∏î‡∏à‡∏≤‡∏Å 3 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏à‡∏≤‡∏∞‡∏ã‡πâ‡∏≥‡πÑ‡∏î‡πâ‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô)
		spawn(function()
			task.wait(0.5)
			recentlyCompleted[part] = nil
			print("Removed", partName, "from recently completed list")
		end)
	end

	-- ‡πÅ‡∏™‡∏î‡∏á UI
	showDrillProgress(payload)

	return target.clicks >= target.requiredClicks
end

-- ===== PUBLIC API =====

function DrillSystem.clearOldDrillingData()
	drillingTargets = {}
	recentlyCompleted = {}
	print("Cleared old drilling data and recently completed list")
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤ Part ‡∏ó‡∏µ‡πà‡∏ä‡∏ô‡∏Å‡∏±‡∏ö DrillArm.PrimaryPart
local function findPartAtDrillArm()
	-- ‡∏´‡∏≤ DrillArm Model ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
	local rescueModelName = player.Name .. "_Rescue"
	local rescueModel = workspace:FindFirstChild(rescueModelName)

	if not rescueModel then
		return nil
	end

	-- ‡∏´‡∏≤ DrillArm ‡πÉ‡∏ô RescueModel
	local drillArm = rescueModel:FindFirstChild("DrillArm")
	if not drillArm or not drillArm.PrimaryPart then
		return nil
	end

	local drillArmPrimaryPart = drillArm.PrimaryPart

	-- ‡∏´‡∏≤ Obstacles folder
	local obstaclesFolder = nil
	local buildingLV1 = workspace:FindFirstChild("Building_LV1")
	if buildingLV1 then
		obstaclesFolder = buildingLV1:FindFirstChild("Obstacles")
	end
	if not obstaclesFolder then
		obstaclesFolder = workspace:FindFirstChild("Obstacles")
	end

	if not obstaclesFolder then
		return nil
	end

	-- ‡πÉ‡∏ä‡πâ Raycast ‡∏¢‡∏¥‡∏á‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å DrillArm.PrimaryPart ‡∏ï‡∏≤‡∏°‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏Ç‡∏≠‡∏á Rescue bot
	local rayOrigin = drillArmPrimaryPart.Position
	-- ‡∏ñ‡πâ‡∏≤ LookVector ‡∏¢‡∏¥‡∏á‡πÑ‡∏õ‡∏ã‡πâ‡∏≤‡∏¢ ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ RightVector ‡πÅ‡∏ó‡∏ô (‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏£‡∏¥‡∏á‡πÜ)
	local rayDirection = rescueModel.PrimaryPart.CFrame.RightVector * DrillConfig.DETECTION_RANGE

	-- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ RaycastParams
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Exclude
	rayParams.FilterDescendantsInstances = {rescueModel, character}  -- ‡πÑ‡∏°‡πà‡∏ä‡∏ô Rescue bot ‡πÅ‡∏•‡∏∞ character

	-- ‡∏™‡∏£‡πâ‡∏≤‡∏á visual debug beam
	local function createDebugBeam(startPos, endPos, color)
		local attachment0 = Instance.new("Attachment")
		local attachment1 = Instance.new("Attachment")
		local part0 = Instance.new("Part")
		local part1 = Instance.new("Part")

		-- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ parts
		part0.Anchored = true
		part0.CanCollide = false
		part0.Transparency = 1
		part0.Size = Vector3.new(0.1, 0.1, 0.1)
		part0.Position = startPos
		part0.Parent = workspace

		part1.Anchored = true
		part1.CanCollide = false
		part1.Transparency = 1
		part1.Size = Vector3.new(0.1, 0.1, 0.1)
		part1.Position = endPos
		part1.Parent = workspace

		attachment0.Parent = part0
		attachment1.Parent = part1

		-- ‡∏™‡∏£‡πâ‡∏≤‡∏á beam
		local beam = Instance.new("Beam")
		beam.Attachment0 = attachment0
		beam.Attachment1 = attachment1
		beam.Color = ColorSequence.new(color)
		beam.Width0 = 0.3
		beam.Width1 = 0.3
		beam.FaceCamera = true
		beam.Parent = part0

		-- ‡∏•‡∏ö‡∏´‡∏•‡∏±‡∏á 0.5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
		task.delay(0.5, function()
			part0:Destroy()
			part1:Destroy()
		end)
	end

	-- Raycast
	local rayResult = workspace:Raycast(rayOrigin, rayDirection, rayParams)

	if rayResult and rayResult.Instance then
		local hitPart = rayResult.Instance
		-- ‡∏™‡∏£‡πâ‡∏≤‡∏á beam ‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏ñ‡πâ‡∏≤‡πÄ‡∏à‡∏≠ part
		createDebugBeam(rayOrigin, rayResult.Position, Color3.fromRGB(0, 255, 0))
		warn("Raycast hit:", hitPart.Name, "Distance:", rayResult.Distance, "Position:", hitPart.Position)

		if (hitPart:IsA("BasePart") or hitPart:IsA("MeshPart")) then
			-- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô Obstacles folder (‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å‡∏ä‡∏∑‡πà‡∏≠)
			local isInObstacles = false
			local ancestor = hitPart.Parent
			while ancestor and ancestor ~= workspace do
				if ancestor.Name == "Obstacles" then
					isInObstacles = true
					break
				end
				ancestor = ancestor.Parent
			end

			warn("  IsInObstacles:", isInObstacles, "IsBodyPart:", isBodyPart(hitPart), "RecentlyCompleted:", recentlyCompleted[hitPart] ~= nil)

			-- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà body part ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà part ‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏á‡πÄ‡∏à‡∏≤‡∏∞‡πÄ‡∏™‡∏£‡πá‡∏à
			if isInObstacles and not isBodyPart(hitPart) and not recentlyCompleted[hitPart] then
				warn("‚úì Found valid drilling target:", hitPart.Name)
				return {
					part = hitPart,
					distance = rayResult.Distance
				}
			end
		end
	else
		-- ‡∏™‡∏£‡πâ‡∏≤‡∏á beam ‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡∏≠‡∏∞‡πÑ‡∏£
		local endPos = rayOrigin + rayDirection
		createDebugBeam(rayOrigin, endPos, Color3.fromRGB(255, 0, 0))
		warn("‚úó Raycast hit nothing - DrillArm at:", rayOrigin, "Direction:", rayDirection)
	end

	return nil
end

function DrillSystem.handleDrillingClick(clickPosition)
	-- ‡∏ñ‡πâ‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏à‡∏≤‡∏∞ part ‡∏≠‡∏¢‡∏π‡πà ‡πÉ‡∏´‡πâ‡πÄ‡∏à‡∏≤‡∏∞‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡πÄ‡∏•‡∏¢‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏≤ part ‡πÉ‡∏´‡∏°‡πà
	if currentDrillingPart and drillingTargets[currentDrillingPart] then
		warn("‚öô Continuing to drill:", currentDrillingPart.Name)
		local targetPart = {part = currentDrillingPart, distance = 0}
		local completed = startDrilling(targetPart)

		if completed then
			warn("‚úì Drilling completed for:", targetPart.part.Name)
		else
			local target = drillingTargets[targetPart.part]
			warn(string.format("‚öô Drilling %s... (%d/%d clicks)",
				target.partName, target.clicks, target.requiredClicks))
		end

		return true -- ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏à‡∏≤‡∏∞ part ‡πÄ‡∏î‡∏¥‡∏°‡∏≠‡∏¢‡∏π‡πà
	end

	-- ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ target ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏à‡∏≤‡∏∞‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏´‡πâ‡∏´‡∏≤ part ‡πÉ‡∏´‡∏°‡πà
	local targetPart = findPartAtDrillArm()

	if targetPart then
		warn("üéØ New drilling target found:", targetPart.part.Name)
		local completed = startDrilling(targetPart)

		if completed then
			warn("‚úì Drilling completed for:", targetPart.part.Name)
		else
			local target = drillingTargets[targetPart.part]
			warn(string.format("‚öô Drilling %s... (%d/%d clicks)",
				target.partName, target.clicks, target.requiredClicks))
		end

		return true -- ‡∏°‡∏µ target ‡πÉ‡∏´‡πâ‡πÄ‡∏à‡∏≤‡∏∞
	else
		warn("‚úó No part found at DrillArm position")
	end

	return false -- ‡πÑ‡∏°‡πà‡∏°‡∏µ target ‡πÉ‡∏´‡πâ‡πÄ‡∏à‡∏≤‡∏∞
end

function DrillSystem.hideDrillProgress()
	hideDrillProgress()
end

function DrillSystem.showDrillProgress(payload)
	showDrillProgress(payload)
end

-- ===== DISTANCE CHECK SYSTEM =====

-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å Part ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏à‡∏≤‡∏∞
local function checkDrillingDistance()
	if not currentDrillingPart then
		return
	end

	-- ‡∏´‡∏≤ RescueOriginal Model ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
	local rescueModelName = player.Name .. "_Rescue"
	local rescueModel = workspace:FindFirstChild(rescueModelName)

	if not rescueModel or not rescueModel.PrimaryPart then
		return
	end

	local rescuePrimaryPart = rescueModel.PrimaryPart
	local distance = (currentDrillingPart.Position - rescuePrimaryPart.Position).Magnitude

	-- ‡∏ñ‡πâ‡∏≤‡∏´‡πà‡∏≤‡∏á‡πÄ‡∏Å‡∏¥‡∏ô DETECTION_RANGE + buffer ‡πÉ‡∏´‡πâ reset
	local maxDistance = DrillConfig.DETECTION_RANGE + 5 -- ‡πÄ‡∏û‡∏¥‡πà‡∏° buffer 5 studs
	if distance > maxDistance then
		print("Rescue bot moved away from drilling target:", currentDrillingPart.Name, "Distance:", math.floor(distance), "Max:", maxDistance)

		-- ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏à‡∏≤‡∏∞
		if drillingTargets[currentDrillingPart] then
			print("Resetting drilling progress for:", currentDrillingPart.Name)
			drillingTargets[currentDrillingPart] = nil
		end
		currentDrillingPart = nil

		-- ‡∏ã‡πà‡∏≠‡∏ô UI
		hideDrillProgress()
	end
end

-- ‡πÄ‡∏£‡∏¥‡πà‡∏° loop ‡πÄ‡∏ä‡πá‡∏Ñ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á
RunService.Heartbeat:Connect(function()
	if currentDrillingPart then
		checkDrillingDistance()
	end
end)

-- Character update handler
player.CharacterAdded:Connect(function(newCharacter)
	character = newCharacter
	-- ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡πÉ‡∏´‡∏°‡πà
	drillingTargets = {}
	currentDrillingPart = nil
	hideDrillProgress()
end)

-- Listen for drill complete events from server (for coin effects)
local remoteEventsFolder = ReplicatedStorage:WaitForChild("RescueBotRemotes")
local drillCompleteRemote = remoteEventsFolder:WaitForChild("DrillComplete")

drillCompleteRemote.OnClientEvent:Connect(function(position, coinAmount)
	-- Show coin effect when drilling is complete
	if position and coinAmount then
		CoinEffect.SpawnCoins(position, coinAmount, player)
	end
end)

return DrillSystem
